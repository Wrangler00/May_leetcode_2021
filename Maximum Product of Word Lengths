Given a string array words, return the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. If no such two words exist, return 0.

 

Example 1:

Input: words = ["abcw","baz","foo","bar","xtfn","abcdef"]
Output: 16
Explanation: The two words can be "abcw", "xtfn".
Example 2:

Input: words = ["a","ab","abc","d","cd","bcd","abcd"]
Output: 4
Explanation: The two words can be "ab", "cd".
Example 3:

Input: words = ["a","aa","aaa","aaaa"]
Output: 0
Explanation: No such pair of words.
 

Constraints:

2 <= words.length <= 1000
1 <= words[i].length <= 1000
words[i] consists only of lowercase English letters.


class Solution {
public:
    int maxProduct(vector<string>& w) {
        int ans=0;
        vector<vector<int>> f = vector<vector<int>>((int)w.size(),vector<int>(26,0));
        
        for(int i=0;i<w.size();i++) for(char ch:w[i])   f[i][ch-'a']++;
        
        for(int i=0;i<w.size();i++){
            for(int j=0;j<w.size();j++){
                if(i==j)    continue;
                bool iscom = false;
                
                for(int k=0;k<26;k++){
                    if(f[i][k] && f[j][k]){
                        iscom = true;
                        break;
                    }
                }
                
                if(!iscom)  ans = max(ans,(int)w[i].length()*(int)w[j].length());
            }
        }
        return ans;
    }
};


//SOLUTION 2 
//very fast solution using bitset

class Solution {
public:
    int maxProduct(vector<string>& w) {
        int ans=0;
        bitset<26> b[(int)w.size()];
        
        for(int i=0;i<w.size();i++) for(char ch:w[i])    b[i][ch-'a'] = 1;
        
        for(int i=0;i<w.size();i++){
            for(int j=0;j<w.size();j++){
                if(i==j || (b[i]&b[j]).any())    continue;
                ans = max(ans,(int)w[i].length()*(int)w[j].length());
            }
        }
        
        return ans;
    }
};
